{"version":3,"sources":["index.js","App.js","useBookSearch.js"],"names":["ReactDOM","render","useState","query","setQuery","pageNumber","setPageNumber","loading","setLoading","error","setError","books","setBooks","hasMore","setHasMore","useEffect","cancel","axios","method","url","params","q","page","cancelToken","CancelToken","c","then","res","prevBooks","console","log","Set","data","docs","map","b","title","length","catch","e","isCancel","useBookSearch","observer","useRef","current","lastBookElementRef","useCallback","node","disconnect","IntersectionObserver","entries","isIntersecting","prevPageNumber","target","observe","type","value","onChange","placeholder","book","index","ref","key","document","getElementById"],"mappings":"wRAIAA,IAASC,OAAO,mBCAD,WAAgB,IAAD,EACFC,mBAAS,IADP,mBACrBC,EADqB,KACdC,EADc,OAEQF,mBAAS,GAFjB,mBAErBG,EAFqB,KAETC,EAFS,OCDf,SAAuBH,EAAOE,GAAa,IAAD,EACzBH,oBAAS,GADgB,mBAChDK,EADgD,KACvCC,EADuC,OAE7BN,oBAAS,GAFoB,mBAEhDO,EAFgD,KAEzCC,EAFyC,OAG7BR,mBAAS,IAHoB,mBAGhDS,EAHgD,KAGzCC,EAHyC,OAIzBV,oBAAS,GAJgB,mBAIhDW,EAJgD,KAIvCC,EAJuC,KAoCvD,OA9BAC,qBAAU,WACRH,EAAS,MACR,CAACT,IAEJY,qBAAU,WAGR,IAAIC,EAkBJ,OApBAR,GAAW,GACXE,GAAS,GAETO,IAAM,CACJC,OAAQ,MACRC,IAAK,qCACLC,OAAQ,CAAEC,EAAGlB,EAAOmB,KAAMjB,GAC1BkB,YAAa,IAAIN,IAAMO,aAAY,SAAAC,GAAC,OAAIT,EAASS,OAChDC,MAAK,SAAAC,GACNf,GAAS,SAAAgB,GAEP,OADAC,QAAQC,IAAI,iBACL,YAAI,IAAIC,IAAJ,sBAAYH,GAAZ,YAA0BD,EAAIK,KAAKC,KAAKC,KAAI,SAAAC,GAAC,OAAIA,EAAEC,gBAGhEtB,EAAWa,EAAIK,KAAKC,KAAKI,OAAS,GAClC7B,GAAW,MACV8B,OAAM,SAAAC,GACHtB,IAAMuB,SAASD,IACnB7B,GAAS,MAEJ,kBAAMM,OAGZ,CAACb,EAAOE,IAEJ,CAAEE,UAASE,QAAOE,QAAOE,WD1B5B4B,CAActC,EAAOE,GAJvBM,EAL0B,EAK1BA,MACAE,EAN0B,EAM1BA,QACAN,EAP0B,EAO1BA,QACAE,EAR0B,EAQ1BA,MAIIiC,EAAWC,mBACjBd,QAAQC,IAAIY,EAAUA,EAASE,SAC/B,IAAMC,EAAqBC,uBAAY,SAAAC,GACjCxC,IACAmC,EAASE,SAASF,EAASE,QAAQI,aACvCN,EAASE,QAAU,IAAIK,sBAAqB,SAAAC,GACtCA,EAAQ,GAAGC,gBAAkBtC,IAC/BP,GAAc,SAAA8C,GAAc,OAAIA,EAAiB,KACjDvB,QAAQC,IAAI,OAAQzB,GACpBwB,QAAQC,IAAIoB,EAAQ,GAAGG,YAG3BxB,QAAQC,IAAIiB,GACRA,GAAML,EAASE,QAAQU,QAAQP,MAClC,CAACxC,EAASM,IAOb,OACE,oCACE,2BAAO0C,KAAK,OAAOC,MAAOrD,EAAOsD,SAPrC,SAAsBlB,GACpBnC,EAASmC,EAAEc,OAAOG,OAClBlD,EAAc,IAK6CoD,YAAY,uBACpE/C,EAAMuB,KAAI,SAACyB,EAAMC,GAChB,OAAIjD,EAAM0B,SAAWuB,EAAQ,EACpB,yBAAKC,IAAKhB,EAAoBiB,IAAKH,GAAOA,GAS1C,yBAAKG,IAAKH,GAAOA,MAG5B,6BAAMpD,GAAW,cACjB,6BAAME,GAAS,YDnDL,MAASsD,SAASC,eAAe,W","file":"static/js/main.e0672df7.chunk.js","sourcesContent":["import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n","import React, { useState, useRef, useCallback } from 'react'\r\nimport useBookSearch from './useBookSearch'\r\nimport styles from './App.css';\r\n\r\nexport default function App() {\r\n  const [query, setQuery] = useState('')\r\n  const [pageNumber, setPageNumber] = useState(1)\r\n\r\n  const {\r\n    books,\r\n    hasMore,\r\n    loading,\r\n    error\r\n  } = useBookSearch(query, pageNumber) //gọi hàm useBookSearch\r\n  //mỗi khi query và page thay đổi, thì callback của useEffect trong hàm sẽ được gọi lại\r\n\r\n  const observer = useRef() //giống biến toàn cục component\r\n  console.log(observer, observer.current);\r\n  const lastBookElementRef = useCallback(node => { //dùng useCallback để hàm lastBookElementRef không bị khởi tạo lại\r\n    if (loading) return\r\n    if (observer.current) observer.current.disconnect() //nếu trước đó có thì bỏ đi, không nghe tại vị trí cũ nữa\r\n    observer.current = new IntersectionObserver(entries => {\r\n      if (entries[0].isIntersecting && hasMore) { //nếu last element giao với viewport và còn data\r\n        setPageNumber(prevPageNumber => prevPageNumber + 1)\r\n        console.log(\"page\", pageNumber)\r\n        console.log(entries[0].target)\r\n      }\r\n    })\r\n    console.log(node);\r\n    if (node) observer.current.observe(node) \r\n  }, [loading, hasMore])\r\n\r\n  function handleSearch(e) {\r\n    setQuery(e.target.value)\r\n    setPageNumber(1)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <input type=\"text\" value={query} onChange={handleSearch} placeholder=\"Tìm sách ...\"></input>\r\n      {books.map((book, index) => {\r\n        if (books.length === index + 1) {\r\n          return <div ref={lastBookElementRef} key={book}>{book}</div>\r\n          //Có 3 cách dùng ref DOM:\r\n          //1. Dùng class component: this.last = React.createRef();\r\n          //this.lastBookElementRef.current trả về DOM element\r\n          //2. Dùng hook: last = useRef(null);\r\n          //last.current trả về DOM element\r\n          //3. Dùng Callback ref: last = (element) => {}\r\n          //element là DOM element, không cần dùng current\r\n        } else {\r\n          return <div key={book}>{book}</div>\r\n        }\r\n      })}\r\n      <div>{loading && 'Loading...'}</div>\r\n      <div>{error && 'Error'}</div>\r\n    </>\r\n  )\r\n}\r\n\r\n","import { useEffect, useState } from 'react'\r\nimport axios from 'axios'\r\n\r\nexport default function useBookSearch(query, pageNumber) {\r\n  const [loading, setLoading] = useState(true)\r\n  const [error, setError] = useState(false)\r\n  const [books, setBooks] = useState([])\r\n  const [hasMore, setHasMore] = useState(false)\r\n\r\n  useEffect(() => {\r\n    setBooks([])  //để khi input thay đổi thì xóa kết quả cũ\r\n  }, [query])\r\n\r\n  useEffect(() => {\r\n    setLoading(true)\r\n    setError(false)\r\n    let cancel\r\n    axios({\r\n      method: 'GET',\r\n      url: 'http://openlibrary.org/search.json',\r\n      params: { q: query, page: pageNumber },\r\n      cancelToken: new axios.CancelToken(c => cancel = c) //lưu cancel là một hàm có khả năng hủy request hiện tại\r\n    }).then(res => {\r\n      setBooks(prevBooks => {\r\n        console.log(\"gọi api \")\r\n        return [...new Set([...prevBooks, ...res.data.docs.map(b => b.title)])]\r\n        //dùng Set để không bị trùng, qua bên kia dùng làm key\r\n      })\r\n      setHasMore(res.data.docs.length > 0) // còn hay không, chứ không phải là còn nhiều hay không\r\n      setLoading(false) //sau khi load xong đánh dấu lại loading = false\r\n    }).catch(e => {\r\n      if (axios.isCancel(e)) return //bắt lỗi lúc request bị cancel do cleanup\r\n      setError(true)\r\n    })\r\n    return () => cancel() //đây là cleanup function, nó sẽ chạy trước mỗi lần callback trong useEffect chạy\r\n    //mục đích: khi gõ quá nhanh, get API gối nhau, chạy cleanup để hủy API trước đó\r\n    //tránh hiển thị lung tung, và giải phóng bộ nhớ\r\n  }, [query, pageNumber])\r\n\r\n  return { loading, error, books, hasMore }\r\n}\r\n"],"sourceRoot":""}